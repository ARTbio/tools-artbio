<tool id="cat_multi_datasets" name="Concatenate multiple datasets" version="1.0">
    <description>tail-to-head by specifying how</description>
    <command><![CDATA[
        #if $headers == 0:
            #set $concat_command = "cat"
        #else:
            #set $concat_command = 'tail -q -n +'+ str(int($headers)+1)
        #end if
        #*#if $global_condition.input_type == "nested_collection":
            #def get_parents($current_lvl, $parget_level, $parent):
                #set $parents = []
                #if $current_lvl < $target_lvl -1:
                    #for $p in $parent:
                        $get_parents($current_lvl+1,$target_lvl,$p)
                    #end for
                #else:
                    #for $p in $parent:
                        #set $parents.append($p)
                    #end for
                #end if
            #end def
            #if $global_condition.level > 1:
                $get_parents(0, $global_condition.level, $global_condition.inputs)
                echo "$parents";
            #end if
        #end if*#
        #if $global_condition.input_type == "singles":
            #if $dataset_names == "No":
                $concat_command
                #for $file in $global_condition.inputs
                    '$file'
                #end for
                > '$out_file1'
            #else:
                #for $file in $global_condition.inputs
                    #if $file.ext[-2:] == "gz":
                        printf "# ${file.element_identifier}\n" >> '$out_file1' &&
                        gzip -dc "$file" | $concat_command >> '$out_file1' &&
                    #else:
                        printf "# ${file.element_identifier}\n" >> '$out_file1' &&
                        $concat_command "$file" >> '$out_file1' &&
                    #end if
                #end for
                sleep 1
            #end if
        #else if $global_condition.input_type == "paired_collection":
            #if $global_condition.paired_cat_type == "by_strand":
                #if $dataset_names == "No":
                    #for $file in $global_condition.inputs
                        $concat_command
                        $file['forward']
                        >> '$forward' &&
                        $concat_command
                        $file['reverse']
                        >> 'reverse'&&
                    #end for
                    sleep 1
                #else:
                    #for $file in $global_condition.inputs.keys()
                        printf "# ${file}_forward\n" >> '$forward' &&
                        $concat_command
                        $global_condition.inputs[$file]['forward']
                        >> '$forward' &&
                        printf "# ${file}_reverse\n" >> '$reverse' &&
                        $concat_command
                        $global_condition.inputs[$file]['reverse']
                        >> '$reverse' &&
                    #end for
                    sleep 1
                #end if
            #else if $global_condition.paired_cat_type == "by_pair":
                mkdir concatenated &&
                #if $dataset_names == "No":
                    #for $file in $global_condition.inputs.keys()
                        $concat_command
                        $global_condition.inputs[$file]['forward']
                        > concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                        $concat_command
                        $global_condition.inputs[$file]['reverse']
                        >> concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                    #end for
                    sleep 1
                #else:
                    #for $file in $global_condition.inputs.keys()
                        printf "# ${file}_forward\n" > concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                        $concat_command
                        $global_condition.inputs[$file]['forward']
                        >> concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                        printf "# ${file}_reverse\n" >> concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                        $concat_command
                        $global_condition.inputs[$file]['reverse']
                        >> concatenated/'${file}.${global_condition.inputs[$file]['reverse'].ext}.listed' &&
                    #end for
                    sleep 1
                #end if
            #else if $global_condition.paired_cat_type == "all":
                #if $dataset_names == "No":
                    #for $file in $global_condition.inputs.keys()
                        $concat_command
                        $global_condition.inputs[$file]['forward']
                        >> $out_file1 &&
                        $concat_command
                        $global_condition.inputs[$file]['reverse']
                        >> $out_file1 &&
                    #end for
                    sleep 1
                #else:
                    #for $file in $global_condition.inputs.keys()
                        printf "# ${file}_forward\n" > $out_file1 &&
                        $concat_command
                        $global_condition.inputs[$file]['forward']
                        >> $out_file1 &&
                        printf "# ${file}_reverse\n" >> $out_file1 &&
                        $concat_command
                        $global_condition.inputs[$file]['reverse']
                        >> $out_file1 &&
                    #end for
                    sleep 1
                #end if
            #end if
        #end if
        ]]>
    </command>
    <inputs>
        <conditional name="global_condition">
            <param name="input_type" type="select" label="What type of data do you wish to concatenate?" help="Depending on the type of input selected the concatenation options will differ">
                <option value="singles">Single datasets</option>
                <option value="paired_collection">Paired collection</option>
                <option value="nested_collection">Datasets in nested collection</option>
            </param>
            <when value="singles">
                <param name="inputs" type="data" label="Concatenate Datasets" multiple="True" help="All inputed datasets will be concatenated tail-to-head."/>
            </when>
            <when value="paired_collection">
                <param name="inputs" type="data_collection" collection_type="list:paired" label="Input paired collections to concatenate"/>
                <param name="paired_cat_type" type="select" label="What type of concatenation do you wish to perform?">
                    <option value="by_strand">Concatenate all datsets of same strand (outputs a single pair of datasets)</option>
                    <option value="by_pair">Concatenate pairs of datasets (outputs an unpaired collection of datasets)</option>
                    <option value="all">Concatenate all datasets into a single file regardless of strand (outputs a single file)</option>
                </param>
            </when>
            <when value="nested_collection">
                <param name="inputs" type="data_collection" label="Select the nested collection to concatenate datasets from"/>
                <param name="level" type="integer" min="1" value="1" label="Select at wich level do you wish to concatenate the datasets." help="Refer to help for a detailed example of how this option works."/>
            </when>
        </conditional>
        <param name="dataset_names" type="boolean" label="Include dataset names?" truevalue="Yes" falsevalue="No" checked="false" help="If 'Yes' is selected '#name of dataset' will be added when concatenating."/>
        <param name="headers" type="integer" label="Number of lines to skip at the beginning of each concatenation:" value="0" help="This paremeter exists so as to not concatenate comments or headers contained at the start of the files."/>
    </inputs>
    <outputs>
        <data name="out_file1" format_source="inputs" metadata_source="inputs" label="Concatenated datasets">
            <filter>global_condition['input_type'] == 'singles' or (global_condition['input_type'] == 'paired_collection' and global_condition['paired_cat_type'] == 'all')</filter>
        </data>
        <collection name="paired_output" type="paired" label="Concatenation by strtand">
            <data name="forward" />
            <data name="reverse" />
            <filter>global_condition['input_type'] == 'paired_collection' and global_condition['paired_cat_type'] == 'by_strand'</filter>
        </collection>
        <collection name="list_output" type="list" label="Concatenation by pairs">
            <discover_datasets pattern="(?P&lt;name&gt;.*)\.(?P&lt;ext&gt;[^\._]+)\.listed" visible="false" directory="concatenated"/>
            <filter>global_condition['input_type'] == 'paired_collection' and global_condition['paired_cat_type'] == 'by_pair'</filter>
        </collection>
    </outputs>
    <tests>
        <test> <!-- Test 2 single files concatenation with no other option -->
            <param name="input_type" value="singles" />
            <param name="inputs" value="1.bed,2.bed"/>
            <param name="dataset_names" value="No" />
            <param name="headers" value="0" />
            <output name="out_file1" file="cat_wrapper_out1.bed"/>
        </test>
        <test> <!-- Test 2 single files concatenation with dataset names activated -->
            <param name="input_type" value="singles" />
            <param name="inputs" value="1.bed,2.bed"/>
            <param name="dataset_names" value="Yes" />
            <param name="headers" value="0" />
            <output name="out_file1" file="cat_wrapper_out2.bed"/>
        </test>
        <test> <!-- Test 2 single files concatenation skipping 1 line -->
            <param name="input_type" value="singles" />
            <param name="inputs" value="1.bed,2.bed"/>
            <param name="dataset_names" value="No" />
            <param name="headers" value="1" />
            <output name="out_file1" file="cat_wrapper_out3.bed"/>
        </test>
        <test> <!-- Test gz handling with no options -->
            <param name="input_type" value="singles" />
            <param name="inputs" value="1_f.fastq.gz,1_r.fastq.gz"/>
            <param name="dataset_names" value="No" />
            <param name="headers" value="0" />
            <output name="out_file1" file="1.fastq.gz" decompress="True"/>
        </test>
        <test> <!-- Test gz handling with options -->
            <param name="input_type" value="singles" />
            <param name="inputs" value="1_f.fastq.gz,1_r.fastq.gz"/>
            <param name="dataset_names" value="Yes" />
            <param name="headers" value="4" />
            <output name="out_file1" file="1_options.fastq"/>
        </test>
        <!-- Test collection concatenation -->
        <!-- Test paired options -->
        <!-- Test nested -->
    </tests>
    <help>

.. class:: warningmark

**WARNING:** This tool does not check if the datasets being concatenated are in the same format.

-----

**What it does**

Concatenates datasets

-----

**Example**

Concatenating Dataset::

    chrX  151087187  151087355  A  0  -
    chrX  151572400  151572481  B  0  +

with Dataset1::

    chr1  151242630  151242955  X  0  +
    chr1  151271715  151271999  Y  0  +
    chr1  151278832  151279227  Z  0  -

and with Dataset2::

    chr2  100000030  200000955  P  0  +
    chr2  100000015  200000999  Q  0  +

will result in the following::

    chrX  151087187  151087355  A  0  -
    chrX  151572400  151572481  B  0  +
    chr1  151242630  151242955  X  0  +
    chr1  151271715  151271999  Y  0  +
    chr1  151278832  151279227  Z  0  -
    chr2  100000030  200000955  P  0  +
    chr2  100000015  200000999  Q  0  +

-----

Adapted from galaxy's catWrapper.xml to allow multiple input files.

    </help>
</tool>
