--- smRtools.py	2014-06-23 13:03:19.378579103 +0200
+++ smRtools.py.marius	2014-06-23 13:14:36.526596441 +0200

 class SmRNAwindow:
 
-  def readcount (self, size_inf=0, size_sup=1000, upstream_coord=None, downstream_coord=None, polarity="both", method="conservative"):
+  def readcount (self, size_inf=0, size_sup=1000, upstream_coord=None, downstream_coord=None):
+    '''refactored 24-12-2013 to save memory and introduce offset filtering
+    take a look at the defaut parameters that cannot be defined relatively to the instance are they are defined before instanciation
+    the trick is to pass None and then test'''
+    norm=self.norm
+    upstream_coord = upstream_coord or self.windowoffset
+    downstream_coord = downstream_coord or self.windowoffset+self.size-1
+    n=0
+    for offset in self.readDict:
+      if (abs(offset) < upstream_coord or abs(offset) > downstream_coord): continue
+      for i in self.readDict[offset]:
+        if (i>=size_inf and i<= size_sup):
+          n += norm
+    return n
+
+  def forwardreadcount(self, size_inf=0, size_sup=1000, upstream_coord=None, downstream_coord=None):
     '''refactored 24-12-2013 to save memory and introduce offset filtering
     take a look at the defaut parameters that cannot be defined relatively to the instance are they are defined before instanciation
-    the trick is to pass None and then test
-    polarity parameter can take "both", "forward" or "reverse" as value'''
+    the trick is to pass None and then test'''
     upstream_coord = upstream_coord or self.windowoffset
     downstream_coord = downstream_coord or self.windowoffset+self.size-1
-    if upstream_coord == 1 and downstream_coord == self.windowoffset+self.size-1 and polarity == "both":
-      return self.matchedreadsUp +  self.matchedreadsDown
-    if upstream_coord == 1 and downstream_coord == self.windowoffset+self.size-1 and polarity == "forward":
-      return self.matchedreadsUp    
-    if upstream_coord == 1 and downstream_coord == self.windowoffset+self.size-1 and polarity == "reverse":
-      return self.matchedreadsDown    
     n=0
-    if polarity == "both":
-      for offset in xrange(upstream_coord, downstream_coord+1):
-        if self.readDict.has_key(offset):
-          for read in self.readDict[offset]:
-            if (read>=size_inf and read<= size_sup):
-              n += 1
-          if method != "conservative":
-            del self.readDict[offset] ## Carefull ! precludes re-use on the self.readDict dictionary !!!!!! TEST
-        if self.readDict.has_key(-offset):
-          for read in self.readDict[-offset]:
-            if (read>=size_inf and read<= size_sup):
-              n += 1
-          if method != "conservative":
-            del self.readDict[-offset]
-      return n
-    elif polarity == "forward":
-      for offset in xrange(upstream_coord, downstream_coord+1):
-        if self.readDict.has_key(offset):
-          for read in self.readDict[offset]:
-            if (read>=size_inf and read<= size_sup):
-              n += 1
-      return n
-    elif polarity == "reverse":
-      for offset in xrange(upstream_coord, downstream_coord+1):
-        if self.readDict.has_key(-offset):
-          for read in self.readDict[-offset]:
-            if (read>=size_inf and read<= size_sup):
-              n += 1
-      return n
+    for offset in self.readDict:
+      if ((abs(offset) < upstream_coord or abs(offset) > downstream_coord) or offset < 0): continue
+      for i in self.readDict[offset]:
+        if (i>=size_inf and i<= size_sup):
+          n += 1
+    return n
+
+  def reversereadcount(self, size_inf=0, size_sup=1000, upstream_coord=None, downstream_coord=None):
+    '''refactored 24-12-2013 to save memory and introduce offset filtering
+    take a look at the defaut parameters that cannot be defined relatively to the instance are they are defined before instanciation
+    the trick is to pass None and then test'''
+    upstream_coord = upstream_coord or self.windowoffset
+    downstream_coord = downstream_coord or self.windowoffset+self.size-1
+    n=0
+    for offset in self.readDict:
+      if ((abs(offset) < upstream_coord or abs(offset) > downstream_coord) or offset > 0): continue
+      for i in self.readDict[offset]:
+        if (i>=size_inf and i<= size_sup):
+          n += 1
+    return n
 
   def readsizes (self):
     '''return a dictionary of number of reads by size (the keys)'''
@@ -304,10 +301,21 @@
     for offset in self.readDict:
       for size in self.readDict[offset]:
         dicsize[size] = dicsize.get(size, 0) + 1
-    for offset in range (min(dicsize.keys()), max(dicsize.keys())+1):
-      dicsize[size] = dicsize.get(size, 0) # to fill offsets with null values
     return dicsize
     
+  def size_histogram(self):
+    norm=self.norm
+    hist_dict={}
+    hist_dict['F']={}
+    hist_dict['R']={}
+    for offset in self.readDict:
+      for size in self.readDict[offset]:
+        if offset < 0:
+          hist_dict['R'][size] = hist_dict['R'].get(size, 0) - 1*norm
+        else:
+	  hist_dict['F'][size] = hist_dict['F'].get(size, 0) + 1*norm
+    return hist_dict
+
   def statsizes (self, upstream_coord=None, downstream_coord=None):
     ''' migration to memory saving by specifying possible subcoordinates
     see the readcount method for further discussion'''
@@ -383,9 +391,10 @@
 
     
   def readplot (self):
+    norm=self.norm
     readmap = {}
     for offset in self.readDict.keys():
-      readmap[abs(offset)] = ( len(self.readDict[-abs(offset)]) , len(self.readDict[abs(offset)]) )
+      readmap[abs(offset)] = ( len(self.readDict.get(-abs(offset),[]))*norm , len(self.readDict.get(abs(offset),[]))*norm )
     mylist = []
     for offset in sorted(readmap):
       if readmap[offset][1] != 0:
@@ -395,13 +404,13 @@
     return mylist
 
   def readcoverage (self, upstream_coord=None, downstream_coord=None, windowName=None):
-    '''Use by MirParser tool'''
+    '''This method has not been tested yet 15-11-2013'''
     upstream_coord = upstream_coord or 1
     downstream_coord = downstream_coord or self.size
     windowName = windowName or "%s_%s_%s" % (self.gene, upstream_coord, downstream_coord)
     forORrev_coverage = dict ([(i,0) for i in xrange(1, downstream_coord-upstream_coord+1)])
-    totalforward = self.readcount(upstream_coord=upstream_coord, downstream_coord=downstream_coord, polarity="forward")
-    totalreverse = self.readcount(upstream_coord=upstream_coord, downstream_coord=downstream_coord, polarity="reverse")
+    totalforward = self.forwardreadcount(upstream_coord=upstream_coord, downstream_coord=downstream_coord)
+    totalreverse = self.reversereadcount(upstream_coord=upstream_coord, downstream_coord=downstream_coord)
     if totalforward > totalreverse:
       majorcoverage = "forward"
       for offset in self.readDict.keys():
